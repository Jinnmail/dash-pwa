/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

var CACHE = {
	name: 'Application Cache',
	version: '1'
};

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith('/_')) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.ico'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'icons',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// Install service worker, adding all our cache entries
// self.addEventListener('install', function (event) {
// 	console.info('Event: Install');
// 	/*
// 	** check network state after certain time interval
// 	** If online for the first time, create an indexed db and a table
// 	** If online after going offline, hit all requests saved in indexed table to server and empty the table
// 	*/
// 	checkNetworkState(); // creates database
// });

// Activate service worker
// self.addEventListener('activate', (event) => {
// 	console.info('Event: Activate');
// 	event.waitUntil(
// 		self.clients.claim(),
// 		caches.keys().then((cacheNames) => {
// 			return Promise.all(
// 				cacheNames.map((cache) => {
// 					if (cache !== CACHE.name + CACHE.version) {
// 						//delete all old caches or else new version of service worker won't get installed
// 						return caches.delete(cache);
// 					}
// 				})
// 			);
// 		})
// 	);
// });

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// self.addEventListener('fetch', async (event) => {
// 	if (event.request.cache === 'only-if-cached' && event.request.mode !== 'same-origin')
// 		return;
// 	if (event.request.method === 'GET') {
// 		if (event.request.url.includes('/static/') || event.request.mode !== 'cors') {
// 			event.respondWith(fetchResponseFromCache(event.request))
// 			return
// 		}
// 		if (navigator.onLine) {
// 			event.respondWith(cacheRequest(event.request));
// 		} else {
// 			var resp = await fetchResponseFromCache(event.request).catch((e) => { return })
// 			if (resp){
// 				event.respondWith(resp)
// 			}
// 		}
// 	}
// 	else {
// 		if(!navigator.onLine){
// 			//here you can check for specific urls to be saved in indexed db
// 			var authHeader = event.request.headers.get('Authorization');
// 			var reqUrl = event.request.url;
// 			Promise.resolve(event.request.text()).then((payload) => {
// 				//save offline requests to indexed db
// 				saveIntoIndexedDb(reqUrl, authHeader, payload)
// 			})
// 		}
// 	}
// })

function checkNetworkState() {
	setInterval(function () {
		if (navigator.onLine) {
			sendOfflinePostRequestsToServer() // create database
		}
	}, 3000);
}

async function cacheResponse(cache, request, response, data) {
	var responseToCache;
	try {
		if (!request.url.includes('/static/') && request.mode === 'cors') {

			var responseData = await getResponseData(data)

			responseToCache = new Response(btoa(responseData), {
				headers: response.clone().headers
			})
		} else {
			responseToCache = response.clone()
		}
		cache.put(request, responseToCache);
	} catch (err) {
	}
	return response;
}

const cacheRequest = request => caches.open(CACHE.name + CACHE.version).then(cache =>
	fetch(request.clone(), {
		credentials: 'same-origin'
	})
		.then(response =>
			cacheResponse(cache, request.clone(), response, response.clone().text()))
);

const fetchResponseFromCache = (request, returnResponseData) =>
	caches.open(CACHE.name + CACHE.version).then(cache =>
		cache.match(request, { ignoreVary: true }).then(response => returnResponseFromCache(request, response, returnResponseData, cache))
	);

async function returnResponseFromCache(request, response, returnResponseData, cache) {
	if (response && !request.url.includes('/static/') && request.mode === 'cors') {
		var responseData = await getResponseData(response.text())
		if (returnResponseData)
			return responseData
		response = new Response(atob(responseData), {
			headers: response.headers
		})
	}

	if (!!response) {
		return response;
	} else {
		console.log(request.url + ' not yet cached!')
		return fetch(request, { credentials: 'same-origin' }).then(response => cacheResponse(cache, request, response))
	}
}

async function getResponseData(data) {
	let promise = Promise.resolve(data).then((text) => {
		return text
	})
	let result = await promise;
	return result
}

async function sendOfflinePostRequestsToServer() {
	var request = indexedDB.open("TrayTrackingPostDB");
	request.onsuccess = function (event) {
		var db = event.target.result;
		var tx = db.transaction('postrequest', 'readwrite');
		var store = tx.objectStore('postrequest');
		var allRecords = store.getAll();
		allRecords.onsuccess = function () {
			if (allRecords.result && allRecords.result.length > 0) {
				var records = allRecords.result
				//make recursive call to hit fetch requests to server in a serial manner
				var resp = sendFetchRequestsToServer(
					fetch(records[0].url, {
						method: "post",
						headers: {
							'Accept': 'application/json',
							'Content-Type': 'application/json',
							'Authorization': records[0].authHeader
						},
						body: records[0].payload
					}), records[0].url, records[0].authHeader, records[0].payload, records.slice(1))

				for (var i = 0; i < allRecords.result.length; i++)
					store.delete(allRecords.result[i].id)
			}
		};
	}
	request.onupgradeneeded = function (event) {
		var db = event.target.result;
		db.onerror = function (event) {
			console.log("Why didn't you allow my web app to use IndexedDB?!");
		};
		var objectStore;
		if (!db.objectStoreNames.contains('postrequest')) {
			objectStore = db.createObjectStore("postrequest", { keyPath: 'id', autoIncrement: true });
		}
		else {
			objectStore = db.objectStoreNames.get('postrequest');
		}
	}
}

function saveIntoIndexedDb(url, authHeader, payload) {
	var myRequest = {};
	jsonPayLoad = JSON.parse(payload)
	//add payload if required. If not skip parsing json and stringifying it again
	//jsonPayLoad['eventTime'] = getCurrentTimeString(eventTime)
	myRequest.url = url;
	myRequest.authHeader = authHeader;
	myRequest.payload = JSON.stringify(jsonPayLoad);
	var request = indexedDB.open("TrayTrackingPostDB");
	request.onsuccess = function (event) {
		var db = event.target.result;
		var tx = db.transaction('postrequest', 'readwrite');
		var store = tx.objectStore('postrequest');
		store.add(myRequest)
	}
}

async function sendFetchRequestsToServer(data, reqUrl, authHeader, payload, records) {
	let promise = Promise.resolve(data).then((response) => {
		console.log('Successfully sent request to server')
		if (records.length != 0) {
			sendFetchRequestsToServer(
				fetch(records[0].url, {
					method: "post",
					headers: {
						'Accept': 'application/json',
						'Content-Type': 'application/json',
						'Authorization': records[0].authHeader
					},
					body: records[0].payload
				}), records[0].url, records[0].authHeader, records[0].payload, records.slice(1))
		}
		return true
	}).catch((e) => {
		//fetch fails only in case of network error. Fetch is successful in case of any response code
		console.log('Exception while sending post request to server' + e)
		saveIntoIndexedDb(reqUrl, authHeader, payload)
	})
}
